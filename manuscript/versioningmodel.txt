# Versioning models #
 
## ปัญหาการแชร์ไฟล์ ##

เมื่อทำงานร่วมกันหลายๆคน มีปัญหาๆหนึ่งที่อาจจะเกิดขึ้นได้ คือเขียนไฟล์ทับกันไปทับกันมา (ให้นึกถึงภาพ นั่งทำงานกันไกล) คือมันอาจจะเกิดจากความเผลอ ซึ่งนั่นนอนว่ามันจะก่อปัญหาร้ายแรง

ลองนึกภาพ มีคนอยู่ 2 คน Harry กับ Sally ทำงานร่วมโปรเจ็กกัน แต่อยู่กันคนละแผนก (หรืออยู่กันคนละตึก หรืออยู่กันคนละประเทศ) บังเอิญ Harry กับ Sally แก้ไขไฟล์ตัวเดียวกัน เมื่อ Harry แก้ไฟล์เสร็จก่อนก็บันทึก จากนั้น Sally แก้ไขเสร็จจึงบันทึก โค้ดของ Harry จะหายหมด ถูกของ Sally ทับ

นี่คือปัญหา เขาจึงคิด model ในการแก้ไขปัญหาขึ้นมาได้ 2 model

## The Lock-Modify-Unlock Solution ##

หัวใจหลักของ model แบบนี้คือจะยอมให้แก้ไขไฟล์ได้ครั้งละ 1 คนเท่านั้น ลองดูภาพจำลองการทำงานของระบบนี้

เรามีระบบอยู่ระบบหนึ่ง ในนั้นก็มีไฟล์ A อยู่ เริ่มต้น Harry ต้องการจะแก้ไขไฟล์ A จึงทำการส่งคำสั่งขอ lock ไฟล์ (ห้ามคนอื่นแก้ไข นอกจาก Harry คนเดียว) Harray ก็ Read ไฟล์ออกมาเพื่อทำการแก้ไข

ในขณะเดียวกัน Sally ก็อยากจะแก้ไฟล์ A เหมือนกัน จึงส่งคำสั่งขอ Lock ไฟล์  ระบบก็จะตอบกลับมาว่า "ไม่ได้ Harry lock อยู่" Sally ก็ต้องรอ

เมื่อ Harray แก้ไขไฟล์ A เสร็จเรียบร้อย จึงทำการเขียนไฟล์กลับไปยัง Repository และส่งคำสั่งขอ unlock ไฟล์ไปให้ด้วย

Sally มาขอ Lock ใหม่ (ซึ่งทำได้แล้ว Harry ปลดล้อกแล้ว) และอ่านไฟล์ออกมาทำการแก้ไข

![](images/versioningmodel/the_lock_modify_unlock_solution.png)

โมเดลแบบนี้เหมือนจะดี แต่มีช่องโหว่

- lock ตาย : ถ้าหากในวันศุกร์ตอนเย็น Harry ต้องการแก้ไขไฟล์ A จึงทำการขอ lock จากนั้นก็แก้ไขๆๆๆๆ แต่ยังไม่ทันเสร็จ เลิกงานเสียก่อน และ Harry เองก็ลืมว่าตัวเองได้ lock ไฟล์ A ไว้ เสาร์-อาทิตย์ Harry ไปเที่ยวแล้วเกิดอุบัติเหตุ จำต้องลางานต่ออีก 2 วัน เช้าวันจันทร์ Sally ต้องการแก้บั๊กในไฟล์ A แต่ไม่สามารถ lock ได้ จึงจำต้องรอ Harry มาทำงาน  หรือถ้าหาก Harry ไปเที่ยวแล้วโดนรถสิบล้อเหยียบพร้อมโน๊ตบุ๊กที่สะพายอยู่กลางหลัง เละไม่มีชิ้นดี  ไฟล์ถูก lock ไปตลอดกาล
- รอโดยไม่จำเป็น : ในสถานการณ์การทำงานจริง ถึง Harry กับ Sally จะต้องการแก้ไขไฟล์เดียวกัน แต่มักไม่ได้แก้ในตำแหน่งเดียวกัน Harry อาจจะแก้โค้ดที่ต้นไฟล์ Sally แก้โค้ดที่ท้ายไฟล์หรือกลางไฟล์  ไม่ได้ชนกันเลย แล้วทำไมต้องรอ
- lock ไขว้ : Harry ต้องการแก้โค้ดในไฟล์ A จึงขอ lock ไฟล์ A และแก้ไข Sally ต้องการแก้โค้ดในไฟล์ B จึงขอ lock ไฟล์ B และแก้ไข ทีนี้ Harry มาพบว่า โค้ดที่กำลังแก้จะต้องไปแก้ฟังก์ชั่นในไฟล์ B ด้วย จึงขอ lock ไฟล์ B แต่ Repository ตอบกลับมาว่าไม่ได้เพราะ Sally lock อยู่  ส่วนทางฝั่ง Sally เอง ในขณะแก้ไฟล์ B ก็พบว่าจะต้องแก้ไขฟังก์ชั่นในไฟล์ A จึงขอ lock ไฟล์ A แต่ Repository ตอบกลับมาว่าไม่ได้เพราะ Harry lock อยู่ มันจึงเหมือนคนที่กลืนไม่เข้าคายไม่ออก

## The Copy-Modify-Merge Solution ##

หัวใจหลักของ model แบบนี้ คือทุกๆคนแก้ไฟล์ พร้อมๆกันได้ ลองดูภาพจำลองการทำงานของระบบนี้

Harry และ Sally ทั้งสองคนก้อปปี้ไฟล์ A มาไว้ที่เครื่องตัวเอง จากนั้นก็ต่างคนต่างแก้ไขโดยไม่ต้องถามไถ่อีกฝ่ายว่าทำอะไรอยู่ 

เมื่อ Sally แก้ไขไฟล์ A เสร็จตามที่ต้องการ Sally ก็ส่งสิ่งที่แก้ไขไปให้ Repository เก็บลงไฟล์ A Repository ก็เขียนไฟล์ตามที่ Sally แก้ไข จากนั้นเมื่อ Harry แก้ไขไฟล์ A เสร็จ Harry ก็ทำเหมือน Sally คือส่งสิ่งที่แก้ไขไปให้ Repository แต่ทีนี้ Repository ตอบกลับมาว่า คุณจะแก้ไขไฟล์ A ไม่ได้ เพราะ Sally เพิ่งแก้ไขเมื่อกี้เอง ไฟล์ A มีการเปลี่ยนแปลงเกิดขึ้นแล้ว คุณต้องอัปเดตไฟล์ A คุณก่อน

![](images/versioningmodel/the_copy_modify_merge_solution.png)

Repository จึงส่งการเปลี่ยนแปลงที่ Sally ทำกับไฟล์ A มาให้ Harry โค้ดในไฟล์ A ของ Harry ตอนนี้จึงมีโค้ดของ Sally ปนอยู่ด้วย ก็เป็นปัจจุบันแล้ว

จากนั้น Harry จึงส่งสิ่งที่แก้ไขไปยัง Repository อีกครั้ง Repository ก็บันทึกสิ่งที่เปลี่ยนแปลงลงไฟล์ A หลังจากนี้หาก Sally แก้ไขไฟล์ A ก็จะถูกบังคับให้อัปเดตไฟล์ก่อนเสมอ หรือไม่มีการแก้ไขใดๆ แค่อยากอัปเดตการเปลี่ยนแปลงที่คนอื่นทำ ก็สามารถถามเอาจาก Repository ได้

![](images/versioningmodel/the_copy_modify_merge_solution_continue.png)

## สรุป ##

โมเดลแบบ The Copy-Modify-Merge Solution เป็นโมเดลที่ SVN เลือกใช้ แต่ก็แถมโมเดล The Lock-Modify-Unlock Solution มาให้ด้วย เผื่อใครอยากจะใช้ในบางสถานการณ์






